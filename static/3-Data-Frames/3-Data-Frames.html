<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Intro to R for Social Data Science</title>
    <meta charset="utf-8" />
    <meta name="author" content="Merlin Schaeffer  Department of Sociology" />
    <meta name="date" content="2021-09-17" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/tile-view/tile-view.css" rel="stylesheet" />
    <script src="libs/tile-view/tile-view.js"></script>
    <link href="libs/tachyons/tachyons.min.css" rel="stylesheet" />
    <link href="libs/panelset/panelset.css" rel="stylesheet" />
    <script src="libs/panelset/panelset.js"></script>
    <link rel="stylesheet" href="libs/Merlin169.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Intro to R for Social Data Science
## Data Frames &amp; Tibbles
### Merlin Schaeffer<br> Department of Sociology
### 2021-09-17

---

class: clear

&lt;iframe src="https://app.sli.do/event/aflvddc2" height="100%" width="100%" frameBorder="0" style="min-height: 560px;"&gt;&lt;/iframe&gt;

---
# Some vectors




```r
# Add packages to library
library(tidyverse) # Add the tidyverse package to my current library.
library(haven) # Read and handle SPSS, Stata &amp; SAS data (no need to install)
*library(essurvey) # Add ESS API package to library.

# Now create a couple of vectors.
(age &lt;- c(34, 22, 42, 12, 76))
# [1] 34 22 42 12 76
(conti &lt;- factor(x = c("Europe", "Africa", "Africa", "Asia", "S. America"),
                 levels = c("Africa", "Asia", "Australia", "Europe", "N. America", "S. America")))
# [1] Europe     Africa     Africa     Asia       S. America
# Levels: Africa Asia Australia Europe N. America S. America
(employed &lt;- c(FALSE, TRUE, TRUE, TRUE, TRUE))
# [1] FALSE  TRUE  TRUE  TRUE  TRUE
(name &lt;- c("Agnes", "Martin", "Hakan", "Tu", "Thais"))
# [1] "Agnes"  "Martin" "Hakan"  "Tu"     "Thais"
(nr_kids &lt;- c(1, 0, 3, 0, 4))
# [1] 1 0 3 0 4
```

---
background-image: url('http://www.europeansocialsurvey.org/about/news/img/round7.png')
background-size: cover
class: center middle

.white[.font200[**Data Frames**]]

---
# Data frames

**Data frames** organize vectors of *equal length* along their indices.


```r
# Bind our 4 vectors along their index into a data frame.
# Assign that data frame to object "Dat".
(Dat &lt;- data.frame(name, age, conti, employed, nr_kids))
#     name age      conti employed nr_kids
# 1  Agnes  34     Europe    FALSE       1
# 2 Martin  22     Africa     TRUE       0
# 3  Hakan  42     Africa     TRUE       3
# 4     Tu  12       Asia     TRUE       0
# 5  Thais  76 S. America     TRUE       4
```

--

.center[Data frames are the typical "rectangular" way to organize data:]
&lt;img src="https://d33wubrfki0l68.cloudfront.net/6f1ddb544fc5c69a2478e444ab8112fb0eea23f8/91adc/images/tidy-1.png" width="60%" style="display: block; margin: auto;" /&gt;

---
background-image: url('http://www.europeansocialsurvey.org/about/news/img/round7.png')
background-size: cover
class: center middle

&lt;img src="https://raw.githubusercontent.com/rstudio/hex-stickers/master/PNG/tibble.png" width="30%" style="display: block; margin: auto;" /&gt;

---
# Tibbles

**Tibbles** are data frames. But they have some improved features, so we will work with them.

.push-right[

```r
# As a comparison, print the former(!) 
# data frame Dat.
Dat
#     name age      conti employed nr_kids
# 1  Agnes  34     Europe    FALSE       1
# 2 Martin  22     Africa     TRUE       0
# 3  Hakan  42     Africa     TRUE       3
# 4     Tu  12       Asia     TRUE       0
# 5  Thais  76 S. America     TRUE       4
```
]

.push-left[

```r
# Make Dat a tibble and assign it to object "Dat", 
# (effectively overwriting Dat as a tibble).
(Dat &lt;- as_tibble(Dat)) 
# # A tibble: 5 × 5
#   name     age conti      employed nr_kids
#   &lt;chr&gt;  &lt;dbl&gt; &lt;fct&gt;      &lt;lgl&gt;      &lt;dbl&gt;
# 1 Agnes     34 Europe     FALSE          1
# 2 Martin    22 Africa     TRUE           0
# 3 Hakan     42 Africa     TRUE           3
# 4 Tu        12 Asia       TRUE           0
# 5 Thais     76 S. America TRUE           4
```
]

---
# Address single variables .font70[The `$` operator]


```r
# Return variable "conti" contained in tibble Dat. 
# (R for Data Science mentions two further commands.)
Dat$conti
# [1] Europe     Africa     Africa     Asia       S. America
# Levels: Africa Asia Australia Europe N. America S. America
```

--


```r
# Give a summary of numeric vector age contained in Dat.
summary(Dat$age) 
#    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
#    12.0    22.0    34.0    37.2    42.0    76.0
```

--


```r
# Give a summary of factor vector conti contained in Dat.
summary(Dat$conti) 
#     Africa       Asia  Australia     Europe N. America S. America 
#          2          1          0          1          0          1
```

.center[.content-box-green[
Wait, why does `summary()` give me first some summary statistics and then a frequency table?
]]

---
# `select()` several variables
 

```r
# Select from tibble Dat the variables name and nr_kids, 
# and assign them to the new object Dat_small.
(Dat_small &lt;- select(Dat, name, nr_kids))
# # A tibble: 5 × 2
#   name   nr_kids
#   &lt;chr&gt;    &lt;dbl&gt;
# 1 Agnes        1
# 2 Martin       0
# 3 Hakan        3
# 4 Tu           0
# 5 Thais        4
```

---
# `select()` several variables

`select()` has a couple of nice **helper functions**, see `?select` for details.

```r
# Select from object Dat all variables that start with n, 
# and assign the result to a new object Dat_small.
(Dat_small &lt;- select(Dat, starts_with("n")))
# # A tibble: 5 × 2
#   name   nr_kids
#   &lt;chr&gt;    &lt;dbl&gt;
# 1 Agnes        1
# 2 Martin       0
# 3 Hakan        3
# 4 Tu           0
# 5 Thais        4
```

---
# `filter()` cases .font60[Based on values in certain variables]


```r
# Either, use dplyr's (part of tidyverse) filter() function, 
# to return all cases contained in Dat with value "Africa" in conti.
(Dat_small&lt;- dplyr::filter(Dat, conti == "Africa"))
# # A tibble: 2 × 5
#   name     age conti  employed nr_kids
#   &lt;chr&gt;  &lt;dbl&gt; &lt;fct&gt;  &lt;lgl&gt;      &lt;dbl&gt;
# 1 Martin    22 Africa TRUE           0
# 2 Hakan     42 Africa TRUE           3
```

--


```r
# Or use the index, to achieve the same.
(Dat_small &lt;- Dat[Dat$conti == "Africa", ])
# # A tibble: 2 × 5
#   name     age conti  employed nr_kids
#   &lt;chr&gt;  &lt;dbl&gt; &lt;fct&gt;  &lt;lgl&gt;      &lt;dbl&gt;
# 1 Martin    22 Africa TRUE           0
# 2 Hakan     42 Africa TRUE           3
```

.center[.content-box-green[
Why is there a `,` after `"Africa"`?
]]

---
# Index[Rows, and columns]

In contrast to vectors, data frames and tibbles have rows and columns. As in matrix algebra, R's index thus distinguishes `[rows, columns]`. The `,` after `"Africa"` tells R that we talk about rows. To understand how the index method works, remember logical vectors:

.push-left[

```r
# Print factor conti contained in tibble Dat.
Dat$conti 
# [1] Europe     Africa     Africa     Asia       S. America
# Levels: Africa Asia Australia Europe N. America S. America
# Return a logical vector of whether the different 
# elements in Dat$conti equal "Africa".
Dat$conti == "Africa"
# [1] FALSE  TRUE  TRUE FALSE FALSE
# Feed the logical vector to the index of Dat
# to select TRUE cases from "Africa".
(Dat_small &lt;- Dat[Dat$conti == "Africa", ]) 
# # A tibble: 2 × 5
#   name     age conti  employed nr_kids
#   &lt;chr&gt;  &lt;dbl&gt; &lt;fct&gt;  &lt;lgl&gt;      &lt;dbl&gt;
# 1 Martin    22 Africa TRUE           0
# 2 Hakan     42 Africa TRUE           3
```
]

--

.push-right[

```r
# Create a new logical variable called "selector", 
# which identifies cases with "Africa" in Dat$conti.
Dat$selector &lt;- Dat$conti == "Africa"

# Print Dat.
Dat 
# # A tibble: 5 × 6
#   name     age conti      employed nr_kids selector
#   &lt;chr&gt;  &lt;dbl&gt; &lt;fct&gt;      &lt;lgl&gt;      &lt;dbl&gt; &lt;lgl&gt;   
# 1 Agnes     34 Europe     FALSE          1 FALSE   
# 2 Martin    22 Africa     TRUE           0 TRUE    
# 3 Hakan     42 Africa     TRUE           3 TRUE    
# 4 Tu        12 Asia       TRUE           0 FALSE   
# 5 Thais     76 S. America TRUE           4 FALSE
```
]

---
class: clear

# Transform, recode &amp; generate .font60[Variables of tibbles]

To transform and recode simply use `$` to clarify which tibble you are referring to. 

```r
# Center age around the average age.
(Dat$age &lt;- Dat$age - mean(Dat$age))
# [1]  -3.2 -15.2   4.8 -25.2  38.8
```


```r
# Recode "Africa" to "Afrika!".
(Dat$conti &lt;- fct_recode(Dat$conti, "Afrika!" = "Africa"))
# [1] Europe     Afrika!    Afrika!    Asia       S. America
# Levels: Afrika! Asia Australia Europe N. America S. America
```

--

If you rather want to generate a new variable, just give it a name.

```r
# Devide age by its standard deviation; 
# now it is z-standardized (mean = 0, sd = 1).
(Dat$z_age &lt;- Dat$age / sd(Dat$age)) 
# [1] -0.131 -0.620  0.196 -1.028  1.582
```

---
class: clear

# Transform, recode &amp; generate .font60[Several variables of a tibble]

If you want to transform and recode several variables from the same tibble, get used to use `mutate()`. .backgrnote[You will better understand why in Session 6 on piping!]&lt;br&gt;


```r
*(Dat &lt;- mutate(Dat,                              # Use the Dat tibble.
              nr_kids = nr_kids - mean(nr_kids), # Transform to deviation from average.
              z_nr_kids = nr_kids / sd(nr_kids), # z-standardize nr_kids.
              conti = fct_recode(conti,          # Recode conti.
                                 "Europa!" = "Europe", # "Europe" to "Europa!".
                                 "Asien!" = "Asia")    # "Asia" to "Asien!".
*             ) # Don't forget to close mutate's bracket ")"
 ) 
# # A tibble: 5 × 8
#   name      age conti      employed nr_kids selector  z_age z_nr_kids
#   &lt;chr&gt;   &lt;dbl&gt; &lt;fct&gt;      &lt;lgl&gt;      &lt;dbl&gt; &lt;lgl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
# 1 Agnes   -3.20 Europa!    FALSE       -0.6 FALSE    -0.131    -0.330
# 2 Martin -15.2  Afrika!    TRUE        -1.6 TRUE     -0.620    -0.881
# 3 Hakan    4.8  Afrika!    TRUE         1.4 TRUE      0.196     0.771
# 4 Tu     -25.2  Asien!     TRUE        -1.6 FALSE    -1.03     -0.881
# 5 Thais   38.8  S. America TRUE         2.4 FALSE     1.58      1.32
```
.backgrnote[Also, look how RStudio structures the brackets. It helps you to understand, within which function things are happening.]
---
class: clear

# Conditional transform &amp; recode .font60[(i.e., for filtered cases)]

To transform/recode only among certain cases, use `case_when()`.


```r
(Dat &lt;- mutate(
  Dat, # Mutate variables contained in Dat.
* conti = case_when( # Start conditional recode of conti,
*   employed == FALSE &amp; conti == "Afrika!" ~ "Atlantis", # 1. complex condition ~ new value "Atlantis",
*   age &lt; 0 &amp; nr_kids &lt; -1  ~ "Antarctica",              # 2. complex condition ~ new value "Antarctica",
*   TRUE ~ as.character(conti)                           # 3. and all others ~ leave as is;
* ) # close case_when's bracket.
)) # close mutate's (and the print) bracket
# # A tibble: 5 × 8
#   name      age conti      employed nr_kids selector  z_age z_nr_kids
#   &lt;chr&gt;   &lt;dbl&gt; &lt;chr&gt;      &lt;lgl&gt;      &lt;dbl&gt; &lt;lgl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
# 1 Agnes   -3.20 Europa!    FALSE       -0.6 FALSE    -0.131    -0.330
# 2 Martin -15.2  Antarctica TRUE        -1.6 TRUE     -0.620    -0.881
# 3 Hakan    4.8  Afrika!    TRUE         1.4 TRUE      0.196     0.771
# 4 Tu     -25.2  Antarctica TRUE        -1.6 FALSE    -1.03     -0.881
# 5 Thais   38.8  S. America TRUE         2.4 FALSE     1.58      1.32
```

---
class: clear

# Conditional transform &amp; recode .font60[(i.e., for filtered cases)]


```r
(Dat &lt;- mutate(
  Dat, # Mutate variables contained in Dat.
* conti = case_when( # Start conditional recode of conti,
*   employed == FALSE &amp; conti == "Afrika!" ~ "Atlantis", # 1. complex condition ~ new value "Atlantis",
*   age &lt; 0 &amp; nr_kids &lt; -1  ~ "Antarctica",              # 2. complex condition ~ new value "Antarctica",
*   TRUE ~ as.character(conti)                           # 3. and all others ~ leave as is;
* ) # close case_when's bracket.
)) # close mutate's (and the print) bracket .
```

The three lines of this `case_when()` application do the following thing:
1. For all non-employed African cases ~ recode conti to "Atlantis".
2. For all those who're younger than 0 and have less than -1 kids ~ recode conti to "Antarctica".
3. All remaining cases ~ use their original conti values, but transform them to a character vector.
 - .alert[Remember, R is class sensitive!] It will not combine numeric information into a character vector. Because we give `case_when()` `"Atlantis"` and `"Antarctica"` as new values, it assumes that we want to make conti a character vector. Thus we cannot supply the former factor values (which are integer) in line three.

---
# `case_when()` and `NA`


```r
(Dat &lt;- mutate(
  Dat, 
  conti = case_when( # Start conditional recode of conti,
    employed == FALSE &amp; conti == "Afrika!" ~ "Atlantis", # 1. complex condition ~ new value "Atlantis",
    age &lt; 0 &amp; nr_kids &lt; -1  ~ "Antarctica",              # 2. complex condition ~ new value "Antarctica",
*   TRUE ~ NA                           # 3. and all others ~ NA
  ) # close case_when's bracket.            
)) 
# Error: Problem with `mutate()` column `conti`.
# ℹ `conti = case_when(...)`.
# x must be a character vector, not a logical vector.
```

In R vectors are type sensitive; the elements of one vector may only be of one type. If you type `?NA`, you will learn: 
&gt; "*NA is a logical* constant of length 1 which contains a missing value indicator. *NA can be coerced to any other vector type* except raw."

---
# `case_when()` and `NA`

`NA` are type sensitive, too! Therefore, coerce NA to character/numeric with `as.character()`/`as.numeric()`.

```r
(Dat &lt;- mutate(
  Dat, 
  conti = case_when( # Start conditional recode of conti,
    employed == FALSE &amp; conti == "Afrika!" ~ "Atlantis", # 1. complex condition ~ new value "Atlantis",
    age &lt; 0 &amp; nr_kids &lt; -1  ~ "Antarctica",              # 2. complex condition ~ new value "Antarctica",
*   TRUE ~ as.character(NA)                              # 3. and all others ~ NA
  ) # close case_when's bracket.            
)) # close mutate's (and the print) bracket.
# # A tibble: 5 × 8
#   name      age conti      employed nr_kids selector  z_age z_nr_kids
#   &lt;chr&gt;   &lt;dbl&gt; &lt;chr&gt;      &lt;lgl&gt;      &lt;dbl&gt; &lt;lgl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
# 1 Agnes   -3.20 &lt;NA&gt;       FALSE       -0.6 FALSE    -0.131    -0.330
# 2 Martin -15.2  Antarctica TRUE        -1.6 TRUE     -0.620    -0.881
# 3 Hakan    4.8  &lt;NA&gt;       TRUE         1.4 TRUE      0.196     0.771
# 4 Tu     -25.2  Antarctica TRUE        -1.6 FALSE    -1.03     -0.881
# 5 Thais   38.8  &lt;NA&gt;       TRUE         2.4 FALSE     1.58      1.32
```
.backgrnote[Alternatively, you can also use type-specific `NA`: `` `NA_character_` ``, `` `NA_real_` ``, etc..]

---
background-image: url('http://www.europeansocialsurvey.org/docs/img/general_banner.jpg')
background-size: contain
background-position: center

.push-left[
&lt;br&gt;
.center[Please register as a user:]
&lt;iframe src="https://www.europeansocialsurvey.org/user/new" height='500' frameborder='0' width="100%"&gt;&lt;/iframe&gt;
]

.push-right[
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQc8K5da5GSR5c4x4lJBIaBheKgcqfNjFfihonLBJWqbzUYVitp&amp;s" width="50%" style="display: block; margin: auto 0 auto auto;" /&gt;
]
---
# Import downloaded data

The classic way to work with actual data, is to download them to some folder and to then import them to your software environment. The tidyverse contains the following three packages: 

.push-left[
&lt;img src="https://haven.tidyverse.org/logo.png" width="30%" style="display: block; margin: auto;" /&gt;

- The "haven" package allows you to import Stata, SPSS, and SAS files. .backgrnote[See the respective [Haven Website](https://haven.tidyverse.org/).]

```r
# Create an object ESS and assign the 
# imported ESS.dta to it, if you have
# downloaded it into your intro_r folder
ESS &lt;- read_dta("ESS8e02_1.dta")
```
]

.push-right[
.push-left[
&lt;br&gt;
&lt;img src="https://readr.tidyverse.org/logo.png" width="65%" style="display: block; margin: auto;" /&gt;
]
.push-right[
&lt;br&gt;
&lt;img src="https://readxl.tidyverse.org/logo.png" width="65%" style="display: block; margin: auto;" /&gt;
]
.white[vcdv]
- The "readr" package allows you to import csv, tsv and fwf files.&lt;br&gt; .backgrnote[See the respective [Readr Website](https://readr.tidyverse.org/) and [Cheat Sheet](https://rawgit.com/rstudio/cheatsheets/master/data-import.pdf).] 
- The readxl package allows you to read in Excel's xlsx files. .backgrnote[See the respective [Readxl Website](https://readxl.tidyverse.org/).]
]

---
# Importing the ESS via the ESS API

Beware, however, that .alert[using an API assumes you have internet access!] It thus makes sense to have an extra R-Script for Data import and transformation, and then other ones for data analyses and visualization.


```r
# Import the ESS round 9 data via the API
ESS &lt;- import_rounds(rounds = 9, ess_email = "YOUR-EMAIL", format = "spss")
```




```r
ESS
# # A tibble: 49,519 × 572
#    name      essround edition proddate  idno cntry    nwspol netusoft netustm ppltrst pplfair pplhlp polintr psppsgva
#    &lt;chr&gt;        &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;    &lt;dbl&gt; &lt;chr+lb&gt; &lt;dbl+&gt; &lt;dbl+lb&gt; &lt;dbl+l&gt; &lt;dbl+l&gt; &lt;dbl+l&gt; &lt;dbl+&gt; &lt;dbl+l&gt; &lt;dbl+lb&gt;
#  1 ESS9e03_1        9 3.1     17.02.2…    27 AT [Aus…     60 5 [Ever…     180   2 [2]   2 [2]  2 [2] 3 [Har… 3 [Some]
#  2 ESS9e03_1        9 3.1     17.02.2…   137 AT [Aus…     10 5 [Ever…      20   7 [7]   8 [8]  7 [7] 2 [Qui… 3 [Some]
#  3 ESS9e03_1        9 3.1     17.02.2…   194 AT [Aus…     60 4 [Most…     180   5 [5]   7 [7]  7 [7] 4 [Not… 2 [Very…
#  4 ESS9e03_1        9 3.1     17.02.2…   208 AT [Aus…     45 5 [Ever…     120   3 [3]   9 [9]  5 [5] 3 [Har… 2 [Very…
#  5 ESS9e03_1        9 3.1     17.02.2…   220 AT [Aus…     30 1 [Neve…      NA   5 [5]   8 [8]  4 [4] 2 [Qui… 1 [Not …
#  6 ESS9e03_1        9 3.1     17.02.2…   254 AT [Aus…     45 2 [Only…      NA   8 [8]   7 [7]  6 [6] 2 [Qui… 2 [Very…
#  7 ESS9e03_1        9 3.1     17.02.2…   290 AT [Aus…     60 1 [Neve…      NA   6 [6]   1 [1]  3 [3] 4 [Not… 2 [Very…
#  8 ESS9e03_1        9 3.1     17.02.2…   301 AT [Aus…     30 1 [Neve…      NA   7 [7]   7 [7]  7 [7] 3 [Har… 1 [Not …
#  9 ESS9e03_1        9 3.1     17.02.2…   305 AT [Aus…     30 5 [Ever…     120   2 [2]   9 [9]  9 [9] 3 [Har… 1 [Not …
# 10 ESS9e03_1        9 3.1     17.02.2…   400 AT [Aus…     25 4 [Most…     360   7 [7]   4 [4]  4 [4] 4 [Not… 2 [Very…
# # … with 49,509 more rows, and 558 more variables: actrolga &lt;dbl+lbl&gt;, psppipla &lt;dbl+lbl&gt;, cptppola &lt;dbl+lbl&gt;,
# #   trstprl &lt;dbl+lbl&gt;, trstlgl &lt;dbl+lbl&gt;, trstplc &lt;dbl+lbl&gt;, trstplt &lt;dbl+lbl&gt;, trstprt &lt;dbl+lbl&gt;,
# #   trstep &lt;dbl+lbl&gt;, trstun &lt;dbl+lbl&gt;, vote &lt;dbl+lbl&gt;, prtvtcat &lt;dbl+lbl&gt;, prtvtdbe &lt;dbl+lbl&gt;,
# #   prtvtdbg &lt;dbl+lbl&gt;, prtvtgch &lt;dbl+lbl&gt;, prtvtbcy &lt;dbl+lbl&gt;, prtvtecz &lt;dbl+lbl&gt;, prtvede1 &lt;dbl+lbl&gt;,
# #   prtvede2 &lt;dbl+lbl&gt;, prtvtddk &lt;dbl+lbl&gt;, prtvtgee &lt;dbl+lbl&gt;, prtvtees &lt;dbl+lbl&gt;, prtvtdfi &lt;dbl+lbl&gt;,
# #   prtvtdfr &lt;dbl+lbl&gt;, prtvtcgb &lt;dbl+lbl&gt;, prtvtahr &lt;dbl+lbl&gt;, prtvtfhu &lt;dbl+lbl&gt;, prtvtcie &lt;dbl+lbl&gt;,
# #   prtvtcis &lt;dbl+lbl&gt;, prtvtcit &lt;dbl+lbl&gt;, prtvblt1 &lt;dbl+lbl&gt;, prtvblt2 &lt;dbl+lbl&gt;, prtvblt3 &lt;dbl+lbl&gt;, …
```

---
# First steps with the ESS

.push-left[
&lt;img src="./img/dscrgrp.png" width="100%" style="display: block; margin: auto;" /&gt;


```r
# A frequency table to get a first impression of the variables values and frequencies.
table(ESS$dscrgrp)
# 
#     1     2 
#  3697 45379
```
]

--

.push-right[
.center[Not very telling...&lt;br&gt;But remember, R does not do labels,&lt;br&gt; in contrast to Stata or SPSS!]

&lt;img src="https://i.vimeocdn.com/portrait/3399477_300x300" width="40%" style="display: block; margin: auto;" /&gt;
]

---
layout: true
# Importing labelled data!

.pull-left[
R imports Stata and SPSS labels, but cannot handle them. Thus, when you import Stata or SPSS data,&lt;br&gt;
... you need to .alert[change each labelled variable to **numeric or factor** from the outset] of your analysis!!]

---

--

.pull-right[
If you want to use a variable as categorical, use `as_factor()` to make the labels the new factor levels:

```r
# Make the labelled dscrgrp a factor.
*ESS$dscrgrp &lt;- as_factor(ESS$dscrgrp)

# A frequency table to get a first impression of the variables values and frequencies.
table(ESS$dscrgrp)
# 
#        Yes         No    Refusal Don't know  No answer 
#       3697      45379          0          0          0
```
]

---

.pull-right[
If you want to use a variable as numeric, use `zap_labels()` to prohibit problems with the imported labels:


```r
# Strip/zap the labels from the numeric variable agea.
*ESS$agea &lt;- zap_labels(ESS$agea)

# A summary of descriptive statistics to get a first impression of the variable.
summary(ESS$agea)
#    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's 
#    15.0    36.0    52.0    51.1    66.0    90.0     222
```

]

---
layout: false
class: clear

&lt;iframe src="https://app.sli.do/event/aflvddc2" height="100%" width="100%" frameBorder="0" style="min-height: 560px;"&gt;&lt;/iframe&gt;

---
layout: false
class: inverse
# Today's general lessons

1. *Data frames* organize equally-sized vectors along their indices; *Tibbles* are modernized data frames. The indices of data frames/tibbles are organized as `[row, column]`.
2. *Helper functions* are sub-functions that help you to make coding easier in many ways. They only work within the confines of the function for which they were designed as helpers.
3. Addressing variables means to address the columns of a data frame. Filtering cases means to address certain rows. Both is possible via the index `[row, column]`, but the `filter()` and `select()` functions have advantages.
4. R has no labels. The idea is that numeric variables have a scale (e.g., cm, years, DKK), while categorical variables have no true representation in numbers. When you import labelled data from Stata or SPSS, the labels are stored in R but will create confusion in the mid run. Make sure to `zap_labels()` from numeric variables and to treat categorical variables `as_factor()`.

---
class: inverse
# Today's important operators

1. `$`: Allows your to address vectors contained in a data frame/tibble.

---
class: inverse
# Today's (important) functions
1. `data.frame()`: organize several vectors of equal length by their index.
2. `as_tibble()`: take a data frame and make it a Tibble.
3. `summary()`: Give a summary of an object.
4. `select()`: select several variables from a data frame/Tibble.
5. `filter()`: filter cases based on values in certain variables. 
6. `mutate()`: Adds new variables and preserves existing. Good for recoding several variables.
7. `case_when()`: Conditional recode for cases filtered in complex ways.
8. `as_factor()`: Make a labelled Stata/SPSS variable a factor.
9. `zap_labels()`: Make a labelled Stata/SPSS variable numeric.
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="libs/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightLanguage": "r",
"highlightStyle": "zenburn",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "16:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
