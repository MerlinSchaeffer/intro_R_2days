<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Intro to R for Social Data Science</title>
    <meta charset="utf-8" />
    <meta name="author" content="Merlin Schaeffer  Department of Sociology" />
    <meta name="date" content="2021-09-10" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/tile-view/tile-view.css" rel="stylesheet" />
    <script src="libs/tile-view/tile-view.js"></script>
    <link href="libs/tachyons/tachyons.min.css" rel="stylesheet" />
    <link href="libs/panelset/panelset.css" rel="stylesheet" />
    <script src="libs/panelset/panelset.js"></script>
    <link rel="stylesheet" href="libs/Merlin169.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Intro to R for Social Data Science
## Vectors
### Merlin Schaeffer<br> Department of Sociology
### 2021-09-10

---

background-image: url(https://cdn.datamentor.io/wp-content/uploads/2017/11/r-vector.jpg)
background-size: cover
class: center

---
class: clear

&lt;iframe src="https://app.sli.do/event/aflvddc2" height="100%" width="100%" frameBorder="0" style="min-height: 560px;"&gt;&lt;/iframe&gt;

---
# (atomic) Vector



The most fundamental data type in R is a (atomic) **vector**: a sequence/chain/series of information. You can "concatenate" information into a vector by using `c()`:


```r
# Concatenate the sequence 5 4 3 2 1 to a vector, assign it to object x1, and print it.
(x1 &lt;- c(5, 4, 3, 2, 4))
# [1] 5 4 3 2 4
```

--

You can access a specific *element* of a vector via it's vector[**index**]:

```r
# Print the second element of x1.
x1[2]
# [1] 4
```

--

If you want to access several elements, you need to supply another vector to the vector's index:

```r
# Print the second and fourth element of x1.
x1[c(2, 4)]
# [1] 4 2
```

---
background-image: url(https://markosun.files.wordpress.com/2015/06/world-leaders-heights-gra-008.jpg)
background-size: contain
class: center

---
# Numeric vectors

.push-left[
**Numeric** vectors are sequences of numbers.

```r
x1 # Print x1
# [1] 5 4 3 2 4
class(x1) # What class of object is x1?
# [1] "numeric"
```
]

.push-right[
&lt;img src="./img/VectorTypesNum.png" width="100%" style="display: block; margin: auto;" /&gt;
]

---
# **Transform** numeric vectors

To transform numeric vectors, you can use ...

... *arithmetic operators* `+ - * / ^`.

```r
(x1 &lt;- x1 + 5) # Assign the object X1 plus 5 added to each of its elements to x1.
# [1] 10  9  8  7  9
```

--

... a myriad of different *functions*.&lt;br&gt; .backgrnote[See Chapter [5 Data transformation](http://r4ds.had.co.nz/transform.html) of Grolemund and Wickham (2017) for further examples.]


```r
(x1 &lt;- log2(x1)) # Assign the logarithm with base 2 of x1 to x1.
# [1] 3.32 3.17 3.00 2.81 3.17
```

--

.center[.alert[Watch out, R simply overrides existing objects without a warning!]]

--

Because R is **nested**, you can combine arithmetic operators and several functions in one line.


```r
(x1 &lt;- (x1 - mean(x1)) / sd(x1)) # z-standardize x1.
# [1]  1.161  0.387 -0.477 -1.458  0.387
```

---
background-image: url(./img/Categorical.jpg)
background-size: contain
class: center

---
# Factor vectors

.left-column[
&lt;img src="./img/VectorTypesFac.png" width="100%" style="display: block; margin: auto;" /&gt;
]

.right-column[
**Factors** are for categorical variables that make a distinction but whose values cannot be compared on a common scale. They are composed of a sequence of categorical *values* (i.e., argument x), and a (ideally comprehensive) list of potential *levels* (i.e., theoretically-possible values).


```r
# Concatenate argument "x" to a factor and give it a
# comprehensive list "levels" of all potential categories.
*conti &lt;- factor(
* x = c("Europe", "Africa", "Africa", "Asia", "S.America"),
* levels = c("Africa", "Asia", "Australia",
*            "Europe", "N.America", "S.America")
*) 

# Print a frequency table of our new factor vector.
table(conti)
# conti
#    Africa      Asia Australia    Europe N.America S.America 
#         2         1         0         1         0         1
```
]

---
# Factors instead of labels

.left-column[
&lt;img src="https://i.vimeocdn.com/portrait/3399477_300x300" width="80%" style="display: block; margin: auto;" /&gt;
]

.right-column[
.center[.alert[R forces you to decide whether a variable is&lt;br&gt; continuous (numeric) or categorical (factor)]]

- Numeric variables have a scale, such as cm, years, or DKK. Hence there is no need for labels. 
- Categorical variables, by contrast, have no actual representation in numbers.
]

---
# **Recoding** factors

.right-column[
Because factors are categorical, they cannot be&lt;br&gt; *numerically* transformed.&lt;br&gt; .backgrnote[What would be Africa devided by half in comparison to Europe devided by half?]&lt;br&gt;

If you nevertheless try to numerically transform a factor,&lt;br&gt; the result is `NA` (i.e., "not available").


```r
conti * 2
# [1] NA NA NA NA NA
```

.center[.alert[In R factors need to be handled as fundamentally different from numeric!]]

]

--

.left-column[
*Base* R is rather confusing when it comes to factors. We learn to use recode functions from the forcats package, which is part of the tidyverse.
&lt;img src="https://forcats.tidyverse.org/logo.png" width="50%" style="display: block; margin: auto;" /&gt;
]

---
# Wait, what's a **package**?

.left-column[
&lt;img src="http://cdn.osxdaily.com/wp-content/uploads/2016/03/package-file-check.jpg" width="60%" style="display: block; margin: auto;" /&gt;
]

--

.right-column[
A **package** is a collection of functions and their documentation (sometimes also data). Some packages are pre-installed as sub-packages of R's *Base* package. In addition, there are, currently, +17,000 (user-written) packages on the *Comprehensive R Archive Network (CRAN)*. The tidyverse and its forcats package are such user-written packages.

You can install any of the +17,000 (user-written) packages using `install.packages("name_of_the_package")`.

Please all install the tidyverse package now by typing: `install.packages("tidyverse")` into the *console*.

.backgrnote[Do not add the `install.packages()` call to your R Scripts! You will need to install a package only once, and not every time you run your script. If you want to update, use `update.packages()`.]

]

---
# The **library**

.push-left[
Because there are so many user-written packages, they oftentimes contain functions with *conflicting names*. To avoid conflicts, you need to specify for each R session, which packages you want to work with. You do that, by adding the packages to your current R session's **library**.

It is good practice to add all packages to the library on the very top of an R script. Please all add the tidyverse to your library by writing the following as the very first line in your R script.



```r
# Add tidyverse package to library
library(tidyverse) 
```
Some tidyverse functions conflict with Base R's Stats package. .backgrnote[You can always address a function from a specific package by initiating it with `package::function()`.]
]

.push-right[

&lt;img src="https://bucket.trending.com/trending/reddit/2016-12-11/the-incredible-library-at-the-university-of-copenhagen-in-denmark_preview.jpg" width="100%" style="display: block; margin: auto;" /&gt;
]

---
# Back to **recoding** factors

.left-column[
&lt;img src="https://forcats.tidyverse.org/logo.png" width="60%" style="display: block; margin: auto;" /&gt;
]

.right-column[
Factors can best be **recoded** with `forcats::fct_recode()`.


```r
# Recode conti to Danish. Watch out: first the new, then the old value...
*conti &lt;- fct_recode(conti,
*                   "Europa" = "Europe",
*                   "Afrika" = "Africa",
*                   "Asien" = "Asia",
*                   "Suedamerika" = "S. America",
*                   "Nordamerika" = "N. America",
*                   "Australien" = "Australia")

# Frequency table of conti.
table(conti) 
# conti
#     Afrika      Asien Australien     Europa  N.America  S.America 
#          2          1          0          1          0          1
```
]

---
# Back to **recoding** factors

.left-column[
&lt;img src="https://forcats.tidyverse.org/logo.png" width="60%" style="display: block; margin: auto;" /&gt;
]

.right-column[
forcats contains [many more useful functions](https://forcats.tidyverse.org/reference/index.html) to handle factors!&lt;br&gt; .backgrnote[Also check out [Chapter 15 Factors](https://r4ds.had.co.nz/factors.html) of Grolemund and Wickham (2017).]


```r
*conti &lt;- fct_drop(conti) # Drop unused levels.

# Frequency table of conti.
table(conti) 
# conti
#    Afrika     Asien    Europa S.America 
#         2         1         1         1
```


```r
# Reorder factor levels by hand
*conti &lt;- fct_relevel(conti, "Europa", "Afrika", "Suedamerika", "Asien")

# Frequency table of conti.
table(conti) 
# conti
#    Europa    Afrika     Asien S.America 
#         1         2         1         1
```
]

---
# Date vectors

.push-right[
&lt;img src="./img/VectorTypesDate.png" width="100%" style="display: block; margin: auto;" /&gt;
]

.push-left[
**Dates** are vectors of the Year-Month-Day (and sometimes -Time) format.

```r
Sys.Date() # Tell me the date
# [1] "2021-09-10"
```


```r
# Evaluate the logical statement that
# today is smaller (i.e., before) 
# than the deadline for the exam.
Sys.Date() &lt; "2020-05-25"
# [1] FALSE
```

Date vectors are complex, because time is not metric `\(\rightarrow\)` advanced R course.
]

---
# Character vectors

.push-right[
&lt;img src="./img/VectorTypesChar.png" width="100%" style="display: block; margin: auto;" /&gt;
]

.push-left[
**Character**/string vectors are sequences of text.

```r
# Concatenate these five strings as one vector 
# and assign it to object "x2".
x2 &lt;- c("This is", "!", "a", "good idea", "really")

# Return only the first to third character 
# of each string-element of x2.
(x2 &lt;- str_sub(x2, start = 1, end = 3))
# [1] "Thi" "!"   "a"   "goo" "rea"
```
You can **manipulate** them using string functions and *regular expressions* `\(\rightarrow\)` .alert[advanced R course (taught by Friedolin Merhout ;)]
]

---
# Logical vectors

.push-right[
&lt;img src="./img/VectorTypesLogic.png" width="100%" style="display: block; margin: auto;" /&gt;
]

.push-left[
**Logical** vectors are sequences of `TRUE` and `FALSE` statements:

```r
x3 &lt;- c(TRUE, FALSE, TRUE, TRUE, FALSE)
```

Internally, R uses *logical vectors for case selection*. They are thus very important!

```r
x2
# [1] "Thi" "!"   "a"   "goo" "rea"
# Print those elements that x3 identifies as TRUE, 
# but not the FALSE ones.
x2[x3]
# [1] "Thi" "a"   "goo"
```
]

---
# No mixed vectors 

.push-right[
.center[.alert[A (atomic) vector cannot mix types!]]

&lt;img src="./img/VectorTypesLogic.png" width="100%" style="display: block; margin: auto;" /&gt;
]

.push-left[

```r
# Concacenate the sequence 1-4 to a numeric vector
(x4 &lt;- seq(1, 4)) 
# [1] 1 2 3 4

# Replace the third element with the word "test"
x4[3] &lt;- "test" 
x4 # print x4
# [1] "1"    "2"    "test" "4"

# What type of object is x4?
class(x4)
# [1] "character"

# Make x4 a numeric vector again
as.numeric(x4) 
# [1]  1  2 NA  4
```
]

---
# **NA**: **N**ot **A**vailable

In general, missing values in R are `NA`, impossible values (devision by 0) are `NaN` (Not a Number). 


```r
x5 &lt;- c(1, 2, 3, NA, 5, NA, 7)
```

--

.push-left[
Many functions will not ignore `NA` by default and thus return `NA`.


```r
# Estimate mean of x5
mean(x5)
# [1] NA

# Estimate mean of x5 ignoring 
# the NA (i.e., casewise deletion)
mean(x5, na.rm = TRUE) 
# [1] 3.6
```
]

.push-right[
`is.na()` generates logical vectors that identify missing values.

```r
# Which elements are missing?
is.na(x5) 
# [1] FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE

# Which elements are not missing?
!is.na(x5) 
# [1]  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE

# Print only non-missing values of x5
x5[!is.na(x5)] 
# [1] 1 2 3 5 7
```
]

---
class: clear

&lt;iframe src="https://app.sli.do/event/aflvddc2" height="100%" width="100%" frameBorder="0" style="min-height: 560px;"&gt;&lt;/iframe&gt;

---
class: inverse
# Today's general lessons

1. The most fundamental data type in R is a (atomic) *vector*: a sequence/chain/series of information. Elements of a vector can be addressed via it's *index* `[i]`. We can feed vectors into an index of another vector to address certain elements.
2. There are different classes of vectors: *numeric*, *factor*, *date*, *character*, and *logical* vectors. We can *transform* numeric vectors with arithmetic operators and a myriad of different functions. We can *recode* factor vectors with the `fct_recode()` function.
3. R has no labels. The idea is that numeric variables have a scale (e.g., cm, years, DKK), while categorical variables have no true representation in numbers.
4. R code may be *nested*, that is, you can write functions into functions. More on that later!
5. `NA`: is "Not Available" and thus the code for missing values in R. `NaN` are impossible numeric values.
6. There are no value lables in R. You will need to decide whether a variable is continuous or categorical.
7. R functions are contained in *packages*, which are bundles of functions along with their documentation. To avoid conflicts, you need to add the packages you will use in a certain R session to the *library*.

---
class: inverse
# Today's (important) functions

1. `install.packages()`: Installs packages from CRAN.
2. `library()`: adds a package to the library for the current session.
3. `c()`: concatenate a sequence to a vector.
4. `factor()`: Make a vector categorical.
5. `fct_recode`: Recode values of a factor.
6. `as.numeric()`: Make a vector numeric.
6. `table()`: simple frequency or cross table.
7. `is.na()`: generate logical vector that identifies missing values.
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="libs/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightLanguage": "r",
"highlightStyle": "zenburn",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "16:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
